## 三次握手

### 过程

刚开始时客户端处于 closed 状态，服务端处于 listen 状态

1. 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号（ISN，动态的）。此时客户端处于 SYN_Send 状态。
2. 第二次握手：服务端收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指明了自己的初始化序列号，同时会把客户端的 ISN+1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 状态。
3. 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文。同样也是把服务端的 ISN+1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 established 状态。
4. 服务器收到 ACK 报文后，也处于 established 状态（代表一个打开的连接，数据可以传送给用户），此时，双方建立连接。

### 三次握手的作用

1. 确认双方的接受能力、发送能力是否正常
2. 指定自己的初始化序列号，为后面的可靠传送做准备

### 相关问题

#### 1. ISN 是固定的吗？

不是，如果是固定的，容易被猜出，从而受到攻击。ISN 的作用是以便让对方知道接下来接收数据的时候如何按序列号组装数据。

#### 2. 什么是半连接状态？

服务端第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立连接，为半连接状态。

#### 3. 三次握手过程中可以携带数据吗？

第一、二次不可以，第三次可以。

## 四次挥手

### 过程

刚开始双方都处于 established 状态，且是客户端先发起关闭请求。

1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号，此时客户端处于 FIN_WAIT1 状态。
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，报文为客户端的序列号值+1，表明已经收到客户端的报文，此时服务端处于 CLOSE_WAIT 状态。
3. 第三次挥手：如果服务端也想断开连接了，就会发给客户端 FIN 报文，指定一个序列号，此时服务端处于 LAST_ACK 状态。
4. 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，报文为服务端的序列号+1，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文后才会进入 CLOSED 状态。
5. 服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

### 为什么客户端发送 ACK 后不直接关闭

要确保服务器是否已经收到了客户端的 ACK 报文，如果没有收到的话，服务端会重新发 FIN 给客户端，客户端再次收到 ACK 报文之后，就会知道之前的 ACK 报文丢了，然后再次发送 ACK 报文。处于 TIME_WAIT 的持续时间至少是一个报文的来回时间，一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功接收 ACK 报文，此时转为 CLOSED 状态。
